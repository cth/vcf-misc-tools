#!/usr/bin/env ruby
# Copyright 2014 Christian Theil Have
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
# INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
# PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT 
# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE 
# OR THE USE OR OTHER DEALINGS IN THE SOFTWARE
require 'bio-samtools'
require 'optparse'
require 'zlib'
require 'pp'

def gzfile?(file)
	if /^.*gz$/.match(file)  
		Zlib::GzipReader 
	else
		File
	end
end

def chr_to_i(chr) 
	chr=chr.to_s.gsub("chr","")
	if chr =~ /^.*(X|Y|M|MT)$/ then
		({"X" => 23, "Y" => 24, "M" => 26, "MT" => 26 })[$1]
	elsif chr.to_i > 0 
		chr.to_i
	else 
		1000 
	end	
end

def same_chr(chr_a, chr_b) 
	chr_a_i, chr_b_i = chr_to_i(chr_a), chr_to_i(chr_b)
	chr_a_i == chr_b_i
end


def between(in_between, before, after)
	false if before.nil? or after.nil?
	in_between, before, after = in_between.to_i, before.to_i, after.to_i 
	in_between >= before and in_between <= after
end


def vcf_binary_search(vcf, chr, start_pos, end_pos, proximity=1000)
	vcf.seek(0, IO::SEEK_END)
	vcf_size = vcf.pos

	pos = start_pos
	index = vcf_size / 2
	change = index / 2
	previous_index = 0

	loop do
		return if previous_index == index 
		#puts "loop #{index}"
		previous_index = index

		vcf.seek(index, IO::SEEK_SET)
		# We might be in the middle of a line skip to start of next line
		begin 
			line=nil
			vcf.gets
			loop do 
				line = vcf.gets
				break unless line =~ /^#.*/
			end 
			vcfline=Bio::DB::Vcf.new(line)
		rescue EOFError => end_of_file
			return
		end

		begin
			vcfline=Bio::DB::Vcf.new(line)
		rescue 
			puts line
			exit
		end

		if same_chr(chr,vcfline.chrom) and (start_pos - vcfline.pos).abs < proximity
			# seek at least a 2*proximity backwards to avoid overshooting or reading reading only part of relevant line 
			vcf.seek( [ 0, index-(2*proximity) ].max,IO::SEEK_SET) if start_pos - vcfline.pos < 0
			vcf.gets # The first line read might be a "half" line - throw it away
			begin 
				loop do # keep reading lines until we get to start_pos
					line = vcf.gets
					#puts "-> #{line}"
					next if line =~ /^#.*/
					vcfline=Bio::DB::Vcf.new(line)

					# FIXME: We might also read before current chrom (next vs. break)
					break unless same_chr(chr, vcfline.chrom) # we might read past current chromosome

					if between(start_pos,vcfline.pos, vcfline.info["END"])
						vcfline.pos = start_pos
						puts vcfline.inspect.to_s#.tr("\t\t","\\t.\\t") # FIXME: This should be fixed in Bio::DB::Vcf 
					elsif	between(vcfline.pos, start_pos, end_pos)
						puts line
					elsif between(end_pos, vcfline.pos, vcfline.info["END"])
						puts line.gsub("END=#{vcfline.info["END"]}", "END=#{end_pos}")
					elsif vcfline.pos.to_i > end_pos.to_i
						break
					end
				end
			rescue => e
				puts "saved by the bell: #{e.to_s}"
				return
			end
		elsif chr_to_i(chr) < chr_to_i(vcfline.chrom) then
			index = index - change
		elsif chr_to_i(chr) > chr_to_i(vcfline.chrom) then
			index = index + change
		elsif pos < vcfline.pos then 
			index = index - change
		elsif pos > vcfline.pos then
			index = index + change
		end
		change = change / 2
	end
end

options = { :linesize => 1000 }

OptionParser.new do |opts|
	opts.on( '-h', '--help', 'Display this screen' ) do
		puts opts
		exit
	end

	opts.on("-v", "--vcf file.vcf", "VCF file to extract from") do |vcf|
		options[:vcf] = vcf
	end

	opts.on("-c", "--chr chrom", "chromosome") do |chrom|
		options[:chr] = chr_to_i(chrom)
	end 
	
	opts.on("-p", "--pos position", "Position to extract") do |position|
		options[:to] = options[:from] = position.to_i
	end

	opts.on("-f","--from position", "First position to extract") do |pos|
		options[:from] = pos.to_i
	end

	opts.on("-t","--to position", "Last position to extract") do |pos|
		options[:to] = pos.to_i 
	end

	# TODO: In a later version
	# opts.on("-b", "--bed bedfile", "Extract ranges given in bedfifile" ) do |bedfile|
	# end
end.parse!

throw("Missing --vcf input file. Cannot proceed!") unless options.include?(:vcf) 
throw("Missing chromosome/position") unless [:chr, :to, :from].map { |x| options.include?(x) }.inject { |x,y| x and y }
 
options[:from], options[:to] = options[:to], options[:from] if options[:to] < options[:from]

vcf = gzfile?(options[:vcf]).open(options[:vcf]) 

loop do 
	line=vcf.gets
	if line =~ /^#.*/
		puts line
	else
		options[:linesize] = 2*line.size # assuming that the size of first line is representative of rest
		break
	end
end

vcf_binary_search(vcf, options[:chr], options[:from], options[:to],options[:linesize])

vcf.close
