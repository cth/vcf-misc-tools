#!/usr/bin/env ruby
require 'bio-samtools'
require 'optparse'
require 'zlib'

def gzfile?(file)
	if /^.*gz$/.match(file)  
		Zlib::GzipReader 
	else
		File
	end
end

def chr_to_i(chr) 
	chr=chr.to_s.gsub("chr","")
	if chr =~ /^.*(X|Y|M|MT)$/ then
		({"X" => 23, "Y" => 24, "M" => 26, "MT" => 26 })[$1]
	elsif chr.to_i > 0 
		chr.to_i
	else 
		1000 
	end	
end

def same_chr(chr_a, chr_b) 
	chr_a_i, chr_b_i = chr_to_i(chr_a), chr_to_i(chr_b)
	chr_a_i == chr_b_i
end


def between(in_between, before, after)
	puts "-> between"
	false if before.nil? or after.nil?
	in_between, before, after = in_between.to_i, before.to_i, after.to_i 
	in_between >= before and in_between <= after
	puts "<- between"
	in_between >= before and in_between <= after
end


def vcf_binary_search(vcf, chr, start_pos, end_pos, proximity=1000)
	vcf.seek(0, IO::SEEK_END)
	vcf_size = vcf.pos

	pos = start_pos
	index = vcf_size / 2
	change = index / 2
	previous_index = 0

	loop do
		return if previous_index == index 
		puts "loop #{index}"
		previous_index = index

		vcf.seek(index, IO::SEEK_SET)
		# We might be in the middle of a line skip to start of next line
		begin 
			line=nil
			vcf.gets
			loop do 
				line = vcf.gets
				break unless line =~ /^#.*/
			end 
			vcfline=Bio::DB::Vcf.new(line)
		rescue EOFError => end_of_file
			return
		end

		begin
			vcfline=Bio::DB::Vcf.new(line)
		rescue 
			puts line
			exit
		end

		puts vcfline.chrom+":"+vcfline.pos.to_s + "---" + chr.to_s  unless line.nil?

		#if previous_index == index or (chr == vcfline.chrom and (start_pos - vcfline.pos).abs < proximity)
		if same_chr(chr,vcfline.chrom) and (start_pos - vcfline.pos).abs < proximity
			# seek at least a 2*proximity backwards to avoid overshooting or reading reading only part of relevant line 
			vcf.seek( [ 0, index-(2*proximity) ].max,IO::SEEK_SET) if start_pos - vcfline.pos < 0
			vcf.gets # The first line read might be a "half" line - throw it away
			begin 
				loop do # keep reading lines until we get to start_pos
					line = vcf.gets
					puts "-> #{line}"
					next if line =~ /^#.*/
					vcfline=Bio::DB::Vcf.new(line)
					next unless same_chr(chr, vcfline.chrom) # we might read past current chromosome

					puts vcfline.pos

					if between(vcfline.pos, start_pos, end_pos)
						puts "here we are"
						puts line
					elsif between(vcfline.pos, start.pos, vcfline_info["END"])
						puts "second case"
						puts line.gsub("END=#{vcfline_info["END"]}", "END=#{end_pos}")
					elsif vcfline.pos > end_pos
						puts "breaking"
						break
					end
					puts "looping"
				end
			rescue
				puts "saved by the bell"
				return
			end
		elsif chr_to_i(chr) < chr_to_i(vcfline.chrom) then
			puts "chr.alert"
			index = index - change
		elsif chr_to_i(chr) > chr_to_i(vcfline.chrom) then
			puts "chr.alert"
			index = index + change
		elsif pos < vcfline.pos then 
			index = index - change
		elsif pos > vcfline.pos then
			index = index + change
		end
		change = change / 2
	end
end

options = {}

OptionParser.new do |opts|
	opts.on( '-h', '--help', 'Display this screen' ) do
		puts opts
		exit
	end

	opts.on("-v", "--vcf file.vcf", "VCF file to extract from") do |vcf|
		options[:vcf] = vcf
	end

	opts.on("-c", "--chr chrom", "chromosome") do |chrom|
		options[:chr] = chr_to_i(chrom)
	end 
	
	opts.on("-p", "--pos position", "Position to extract") do |position|
		options[:to] = options[:from] = position.to_i
	end

	opts.on("-f" "--from position", "First position to extract") do |pos|
		options[:from] = pos.to_i
	end

	opts.on("-t" "--to position", "Last position to extract") do |pos|
		options[:to] = pos.to_i 
	end

	# TODO: In a later version
	# opts.on("-b", "--bed bedfile", "Extract ranges given in bedfifile" ) do |bedfile|
	# end
end.parse!

throw("Missing --vcf input file. Cannot proceed!") unless options.include?(:vcf) 
throw("Missing chromosome/position") unless [:chr, :to, :from].map { |x| options.include?(x) }.inject { |x,y| x and y }

 
options[:from], options[:to] = options[:to], options[:from] if options[:from] < options[:to]

vcf = gzfile?(options[:vcf]).open(options[:vcf]) 

loop do 
	line=vcf.gets
	if line =~ /^#.*/
		puts line
	else
		options[:linesize] = 2*line.size # assuming that the size of first line is representative of rest
		break
	end
end

vcf_binary_search(vcf, options[:chr], options[:from], options[:to])

vcf.close
